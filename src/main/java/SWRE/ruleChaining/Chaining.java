package SWRE.ruleChaining;

import SWRE.Ontology2SDB2MySQL.OWLUtilities;
import SWRE.Ontology2SDB2MySQL.SDBUtilities;
import org.apache.jena.base.Sys;

import java.util.ArrayList;

public class Chaining {

    /*
     * RIGHT NOW, QUERY WITH EITHER ALL ANDS (or) ALL ORS ARE ONLY SUPPORTED
     * EDIT THIS METHOD AFTER FURTHER UPDATES
     */

    public static String createQuery(ArrayList<String> Rule, OWLUtilities owlUtilities, String prefix) throws Exception {

	    int index,loop=0;
    	    String left="";
    	    String right="";
            String query = "";
	    String rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
	    String owl = "http://www.w3.org/2002/07/owl#";
            int len = Rule.size();
	    /*
	     *   Calls overloaded Inserttriples method ,
	     *   this method is to insert into the database that the predicate in the then part of a new rule is also a object property
	     */
	    String status = owlUtilities.insertTriples(rdf, owl, Rule.get(len-2),"type", "ObjectProperty");
	    System.out.println(status);
        
       	    query=query + "SELECT " + Rule.get(len-3) + " " + Rule.get(len-1) + " { ";
	    if(Rule.get(0).charAt(0)=='?')
	    left=Rule.get(0);
	    else
	    left = " <" + prefix + Rule.get(0) +"> ";
	    left = left + " <" + prefix + Rule.get(1) + "> " ;
	    if(Rule.get(2).charAt(0)=='?')
	    left = left + Rule.get(2) + " ";
	    else
	    left = left + "<" + prefix + Rule.get(2) + "> ";
	    //index refer to the index of connector being considered currently
	    index=(3*(loop+1))+loop;
	    while(index<len-3)
	    {
	    	loop++;
	    	//right holds the subject,predicate,object present immediately after the connector 
	    	if(Rule.get(index+1).charAt(0)=='?')
	    	right = Rule.get(index+1) ;
	    	else
	    	right = " <" + prefix + Rule.get(index+1) + "> " ;
	    	right = right + " <" + prefix + Rule.get(index+2) + "> " ;
	    	if(Rule.get(index+3).charAt(0)=='?')
	    	right = right + Rule.get(index+3) + " ";
	    	else
	    	right = right + "<" + prefix + Rule.get(index+3) + "> ";
	    	
	    	//left holds entire query before the present connector
	    	
	    	
	    	if((Rule.get(index)).equals("OR"))
	    	{
	    		left = "{ " + left + " }" + " UNION " + "{ " + right + " }";
	    	}
	    	else if((Rule.get(index)).equals("AND"))
	    	{
	    		left = left + " . " + right;
	    	}
	    	//updating index to get to next connector
	    	index=(3*(loop+1))+loop;
	    }
	    query = query + left + " }";

        return query;
    }

    /*
     * Method to implement forward chaining
     */
    public static void ForwardChaining(ArrayList<ArrayList<String>> ruleList) throws Exception {

        /*
         * Flag sets when no new triple is added after each forward pass iteration
         */
        boolean newTriple = false;

        int ruleListLength = ruleList.size();
        SDBUtilities sdbUtilities = new SDBUtilities();
        sdbUtilities.DBinit();
        OWLUtilities owlUtilities = new OWLUtilities(sdbUtilities);

        /*
         * SELECT (COUNT(*) as ?Triples) WHERE { ?s ?p ?o}
         * SPARQL query to count the number of triples
         */

        int[] previousNumberOfTriples = new int[ruleListLength];

        for(int i=0;i<ruleListLength;i++)   previousNumberOfTriples[i] = -1;

        for(int pass = 0; ; pass++) {

            // Counts number of rules for which no new triple is generated
            int noNewTripleForRuleCount = 0;

            for (int loop = 0; loop < ruleListLength; loop++) {

                // Extract each rule from the rule
                ArrayList<String> Rule = ruleList.get(loop);
                // Create query for the current rule
                String query = createQuery(Rule, owlUtilities, sdbUtilities.getOntologyPrefix());
                System.out.println("Query generated by rule " + loop + " is " + query);
                // Obtaing triples due to the above query
                int ruleLength = Rule.size();
                String subject = Rule.get(ruleLength - 3);
                String predicate = Rule.get(ruleLength - 2);
                String object = Rule.get(ruleLength - 1);
                ArrayList<ArrayList<String>> triples = owlUtilities.SDBQuery(query, subject, object);

                int numberOfTriplesGenerated = triples.size();

                System.out.println(numberOfTriplesGenerated);

                if(previousNumberOfTriples[loop] == -1)
                    previousNumberOfTriples[loop] = numberOfTriplesGenerated;
                else if(previousNumberOfTriples[loop] == numberOfTriplesGenerated)
                    noNewTripleForRuleCount++;
                else {
                    previousNumberOfTriples[loop] = numberOfTriplesGenerated;
                    System.out.println("Iteration " + pass + " Rule " + loop + "yeilded new triples");
                }

//                int l = triples.size();
//                for (int i = 0; i < l; i++) {
//                    int l1 = triples.get(i).size();
//                    for (int j = 0; j < l1; j++) {
//                        System.out.print(triples.get(i).get(j) + " ");
//                    }
//                    System.out.println();
//                }

                // Update the fact table for triples obtained from the above query
                int tripleLength = triples.size();
                String status = "";
                for (int loop1 = 0; loop1 < tripleLength; loop1++) {
                    subject = triples.get(loop1).get(0);
                    object = triples.get(loop1).get(1);
                    status = owlUtilities.insertTriples(subject, predicate, object);
                }
            }
            // No new triple generated for the iteration
            if(noNewTripleForRuleCount == ruleListLength)   break;
        }
    }
}
